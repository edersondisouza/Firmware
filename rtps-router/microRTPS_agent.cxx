// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * <type 'file'> sensor_combined_PubSubMain.cpp
 * This file acts as a main entry point to the application.
 *
 * This file was generated by the tool fastcdrgen.
 */

#include "sensor_combined_Publisher.h"
#include "vehicle_command_ack_Publisher.h"
#include "vehicle_command_Subscriber.h"

#include "UART_node.h"

#include <fastcdr/Cdr.h>
#include <fastcdr/FastCdr.h>
#include <fastcdr/exceptions/Exception.h>
#include <fastrtps/utils/eClock.h>
#include <fastrtps/Domain.h>

#include <unistd.h>

#include <arpa/inet.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <sys/types.h>

#define BUFFER_SIZE 1024
#define USLEEP_MS 500

using namespace eprosima;
using namespace eprosima::fastrtps;

static struct sockaddr_in _sockaddr;

static int setup_udp()
{
    int fd;
    const int broadcast_val = 1;

    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (fd == -1) {
        printf("Could not create socket %d\n", errno);
        return -1;
    }

    _sockaddr.sin_family = AF_INET;
    _sockaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
    _sockaddr.sin_port = htons(13800);

    if (setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &broadcast_val, sizeof(broadcast_val))) {
        printf("Error enabling broadcast %d\n", errno);
        return -1;
    }

    if (fcntl(fd, F_SETFL, O_NONBLOCK | FASYNC) < 0) {
        printf("Error setting socket fd as non-blocking %d\n", errno);
        return -1;
    }

    return fd;
}

int main(int argc, char** argv)
{
    int udp_fd, fd, epollfd;
    UART_node m_uartNode;
    std::string uart = "/dev/ttyACM0";
    if (argc > 1) uart = std::string(argv[1]);

    epollfd = epoll_create1(EPOLL_CLOEXEC);
    if (epollfd == -1) {
        std::cerr << "Epoll create error " << std::endl;
        return -1;
    }

    fd = m_uartNode.init_uart(uart.c_str(), 460800);
    if (fd < 0)
    {
        printf("EXITING...\n");
        return -1;
    }

    if ((udp_fd = setup_udp()) < 0)
        return -1;

    int usleep_ms = USLEEP_MS;
    if (argc > 2) usleep_ms = atoi(argv[2]);

    char data_buffer[BUFFER_SIZE] = {};

    // Create subscribers
    vehicle_command_Subscriber vehicle_command_sub;
    if (true == vehicle_command_sub.init()) std::cout << "vehicle_command subscriber created" << std::endl;
    else std::cout << "ERROR creating vehicle_command subscriber" << std::endl;

    // Create publishers
    sensor_combined_Publisher sensor_combined_pub;
    sensor_combined_pub.init();
    vehicle_command_ack_Publisher vehicle_command_ack_pub;
    vehicle_command_ack_pub.init();

    int received = 0, sent = 0, wait = 0, total_read = 0;
    int read = 0;
    char topic_ID = 255;

    struct timespec begin;
    bool start = true, receiving = false;
    uint8_t seq;

    // Add fds on epoll
    struct epoll_event epev = {};
    epev.events = EPOLLIN;
    epev.data.fd = fd;

    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &epev) < 0) {
        printf("Epoll add UART fd error %d\n", errno);
        return -1;
    }

    epev.data.fd = udp_fd;

    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, udp_fd, &epev) < 0) {
        printf("Epoll add UDP fd error %d\n", errno);
        return -1;
    }

    struct epoll_event events[8];
    do
    {
        if (!receiving)
        {
            clock_gettime(0, &begin);
        }

        int r = epoll_wait(epollfd, events, 8, usleep_ms);
        if (r < 0 && errno == EINTR)
            continue;

        bool udp = false;
        bool uart = false;
        for (int i = 0; i < r; i++) {
            if (events[i].data.fd == udp_fd)
                udp = true;
            if (events[i].data.fd == fd)
                uart = true;
        }

        if (uart) {
            // Publish messages received from UART
            uint8_t seq;
            m_uartNode.read();
            while (0 < (read = m_uartNode.parseRTPSfromUART(&topic_ID, &seq, data_buffer, BUFFER_SIZE)))
            {
                printf("read topicID %d\n", topic_ID);
                switch (topic_ID)
                {
                    case 58:
                    {
//                        printf("sensor-combined\n");
//                        printf("buf %s\n", data_buffer);
                        sensor_combined_ st;
                        eprosima::fastcdr::FastBuffer cdrbuffer(data_buffer, sizeof(data_buffer));
                        eprosima::fastcdr::Cdr cdr_des(cdrbuffer);
                        st.deserialize(cdr_des);
                        sensor_combined_pub.publish(&st);
                        //printf("                >>[%d] %lu\n", <built-in function id>, st.timestamp());
                        ++received;
                        total_read += read;
                    }
                    break;
                    case 79:
                    {
                        vehicle_command_ack_ st;
                        eprosima::fastcdr::FastBuffer cdrbuffer(data_buffer, sizeof(data_buffer));
                        eprosima::fastcdr::Cdr cdr_des(cdrbuffer);
                        st.deserialize(cdr_des);
                        vehicle_command_ack_pub.publish(&st);
                        //printf("                >>[%d] %lu\n", <built-in function id>, st.timestamp());
                        ++received;
                        total_read += read;
                    }
                    break;
                }
                receiving = true;
                wait = 0;
            }

            int len;
            while ((len = m_uartNode.parseMavlinkFromUART(data_buffer, sizeof(data_buffer))) > 0) {
                        printf("mavlink\n");
                        printf("buf %s\n", data_buffer);
                // Just send it, as is, to mavlink-router
                int ret = sendto(udp_fd, data_buffer, len, 0,
                        (struct sockaddr *)&_sockaddr, sizeof(_sockaddr));
                // cout << "sent to udp " << ret << " errno " << errno << endl;
            }
        }

        // Send mavlink over UART
        if (udp) {
            // Assumption: we are running side by side with mavlink-router
            // So, UDP won't fail.
            // In the future, mavlink-router and rtps-router should become one
            // (or at least, share memory for this)
            socklen_t addrlen = sizeof(sockaddr);
            ssize_t len = recvfrom(udp_fd, data_buffer, sizeof(data_buffer), 0,
                        (struct sockaddr *)&_sockaddr, &addrlen);

            if (r > 0) {
                int ret = m_uartNode.writeMavlinkToUART(data_buffer, len);

                if (ret > 0) {
                     printf("Wrote mavlink to UART %d\n", ret);
                }
                else {
                    printf("Failed to write mavlink to UART %d\n");
                }
            }
        }

        // Send subscribed topics over UART
        if (vehicle_command_sub.hasMsg())
        {
            printf("Got vehicle_command_\n");
            vehicle_command_ msg = vehicle_command_sub.getMsg();
            eprosima::fastcdr::FastBuffer cdrbuffer(data_buffer, sizeof(data_buffer));
            eprosima::fastcdr::Cdr scdr(cdrbuffer);
            msg.serialize(scdr);
            size_t len = scdr.getSerializedDataLength();
            //printf("[%d]>> %lu\n", <built-in function id>, msg.timestamp());
            m_uartNode.writeRTPStoUART((char) 80, scdr.getBufferPointer(), len);
//            char a[] = "qwertyuiopasdfghjklzxcvbnm";
//            m_uartNode.writeRTPStoUART((char) 80, a, sizeof(a));
            ++sent;
        }

        if (receiving && ++wait > 10)
        {
            struct timespec end;
            clock_gettime(0, &end);
            double elapsed_secs = double(end.tv_sec - begin.tv_sec) + double(end.tv_nsec - begin.tv_nsec)/double(1000000000);
            printf("\nRECEIVED: %d SENT: %d\n%d bytes in %.03f seconds received %.02fKB/s\n",
                    received, sent, total_read, elapsed_secs, (double)total_read/(1000*elapsed_secs));
            received = sent = total_read = wait = 0;
            receiving = false;
        }
    }while(true);

    return 0;
}
