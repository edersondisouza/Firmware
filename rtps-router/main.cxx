// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * <type 'file'> sensor_combined_PubSubMain.cpp
 * This file acts as a main entry point to the application.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include "vehicle_command_Subscriber.h"

#include "vehicle_status_Publisher.h"
#include "sensor_combined_Publisher.h"
#include "vehicle_command_ack_Publisher.h"

#include "UART_node.h"
#include "topic-id.h"

#include <fastcdr/Cdr.h>
#include <fastcdr/FastCdr.h>
#include <fastcdr/exceptions/Exception.h>
#include <fastrtps/utils/eClock.h>
#include <fastrtps/Domain.h>

#include <unistd.h>

#include <sys/epoll.h>

using namespace std;
using namespace eprosima;
using namespace eprosima::fastrtps;

int main(int argc, char** argv)
{
    UART_node m_uartNode;
    char buffer[210];

    // Create subscribers
    vehicle_command_Subscriber vehicle_command_sub;
    vehicle_command_sub.init();

    // Create publishers
    vehicle_status_Publisher vehicle_status_pub;
    vehicle_status_pub.init();

    sensor_combined_Publisher sensor_combined_pub;
    sensor_combined_pub.init();

    vehicle_command_ack_Publisher vehicle_command_ack_pub;
    vehicle_command_ack_pub.init();

    int epollfd = epoll_create1(EPOLL_CLOEXEC);
    if (epollfd == -1) {
        std::cerr << "Epoll create error " << std::endl;
        return -1;
    }

    int fd = m_uartNode.init_uart("/dev/ttyS1", 460800);
    struct epoll_event epev = {};
    epev.events = EPOLLIN;
    epev.data.ptr = &m_uartNode;

    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &epev) < 0) {
        std::cerr << "Epoll add fd error " << std::endl;
        return -1;
    }

    struct epoll_event events[8];
    char topic_ID = 255;
    do
    {
        int r = epoll_wait(epollfd, events, 8, 500);
        if (r < 0 && errno == EINTR)
            continue;

        if (r != 0) {
            uint8_t seq;
            if (0 != m_uartNode.readFromUART(&topic_ID, &seq, buffer))
            {
                eprosima::fastcdr::FastBuffer cdrbuffer(buffer, sizeof(buffer));
                eprosima::fastcdr::Cdr cdr_des(cdrbuffer);

                // Publish message received from UART
                cout << "SEQ: " << (int)seq << endl;
                switch (topic_ID) {
                case VehicleStatusId: {
                    std::cout << "received vehicle_status" << std::endl;
                    vehicle_status_ st {};
                    st.deserialize(cdr_des);
                    vehicle_status_pub.publish(&st);
                    break;
                }
                case SensorCombinedId: {
                    std::cout << "received sensor_combined" << std::endl;
                    sensor_combined_ sc {};
                    sc.deserialize(cdr_des);
                    sensor_combined_pub.publish(&sc);
                    break;
                }
                case VehicleCommandAckId: {
                    std::cout << "received vehicle_command_ack" << std::endl;
                    vehicle_command_ack_ vca {};
                    vca.deserialize(cdr_des);
                    vehicle_command_ack_pub.publish(&vca);
                    break;
                }
                default:
                    std::cout << "No message msg - id" << (int)topic_ID << " -- " << buffer << endl;
                }

            }
        }

        // Send subscribed topics over UART
        if (vehicle_command_sub.hasMsg()) {
            std::cout << "Received loop-msg" << std::endl;
            vehicle_command_ msg = vehicle_command_sub.getMsg();
            eprosima::fastcdr::FastBuffer cdrbuffer(buffer, sizeof(buffer));
            eprosima::fastcdr::Cdr scdr(cdrbuffer);
            msg.serialize(scdr);
            auto len = scdr.getSerializedDataLength();
            std::cout << "len: " << len << std::endl;
            uint8_t ret = m_uartNode.writeToUART((char) VehicleCommandId, scdr.getBufferPointer(), len);

            if (ret == 0) {
                 std::cout << "Wrote to UART " << ret << std::endl;
            }
            else {
                std::cout << "Failed to write to UART" << std::endl << std::endl;
            }
        }
    }while(true);

    return 0;
}
