@###############################################
@#
@# EmPy template for generating <msg>_uRTPS_UART.cpp file
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - msgs (List) list of all msg files
@#  - multi_topics (List) list of all multi-topic names
@###############################################
@{
import genmsg.msgs
import gencpp
from px_generate_uorb_topic_helper import * # this is in Tools/

topic_names = [single_spec.short_name for single_spec in spec]
}@
// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file sensor_combined_PubSubMain.cpp
 * This file acts as a main entry point to the application.
 *
 * This file was generated by the tool fastcdrgen.
 */

@[for topic in topic_names]
#include "@(topic)_Publisher.h"
#include "@(topic)_Subscriber.h"
@[end for]

#include "UART_node.h"

#include <fastcdr/Cdr.h>
#include <fastcdr/FastCdr.h>
#include <fastcdr/exceptions/Exception.h>
#include <fastrtps/utils/eClock.h>
#include <fastrtps/Domain.h>

#include <unistd.h>



using namespace eprosima;
using namespace eprosima::fastrtps;

int main(int argc, char** argv)
{   
    UART_node m_uartNode;
    char buffer[210];
    std::string uart = "/dev/ttyACM0";
    if (argc > 1) uart = std::string(argv[1]);
    m_uartNode.init_uart(uart.c_str());

// Create subscribers
@[for id, topic in enumerate(topic_names)]
    std::cout << "@(topic) subscriber created" << std::endl;
    @(topic)_Subscriber @(topic)_sub;
    if (@(topic)_sub.init())
    {
        // @(topic)_sub.run();
    }
@[end for]

// Create subscribers
@[for topic in topic_names]
    @(topic)_Publisher @(topic)_pub;
    @(topic)_pub.init();
@[end for]


    char topic_ID = 255;
    do
    {
        if (0 != m_uartNode.readFromUART(&topic_ID, buffer, buffer))
        {
// Publish message received from UART
@[for id, topic in enumerate(topic_names)]
            if (topic_ID == @(id)) {
                std::cout << "Published @(topic)" << std::endl;

                @(topic)_ st;
                memset(&st, 0, sizeof(st));
                eprosima::fastcdr::FastBuffer cdrbuffer(buffer, sizeof(buffer));
                eprosima::fastcdr::Cdr cdr_des(cdrbuffer);
                st.deserialize(cdr_des);
                @(topic)_pub.publish(&st);
            }
@[end for]

// Send subscribed topics over UART
@[for id, topic in enumerate(topic_names)]
            if (@(topic)_sub.hasMsg()) {
                std::cout << "Received loop-msg" << std::endl;
                @(topic)_ msg = @(topic)_sub.getMsg();
                eprosima::fastcdr::FastBuffer cdrbuffer(buffer, sizeof(buffer));
                eprosima::fastcdr::Cdr scdr(cdrbuffer);
                msg.serialize(scdr);
                auto len = scdr.getSerializedDataLength();
                std::cout << "len: " << len << std::endl;
                uint8_t ret = m_uartNode.writeToUART((char) @(id), scdr.getBufferPointer(), len);

                if (ret == 0) {
                    // std::cout << "Wrote to UART" << std::endl << std::endl;
                }
                else {
                    std::cout << "Failed to write to UART" << std::endl << std::endl;
                }
            }
@[end for]
        }
        usleep(10000);
    }while(true);
    
    return 0;
}