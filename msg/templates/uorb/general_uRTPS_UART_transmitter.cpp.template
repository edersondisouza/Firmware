from docutils.parsers.rst.directives import length_or_percentage_or_unitless
@###############################################
@#
@# EmPy template for generating <msg>_uRTPS_UART.cpp file
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - msgs (List) list of all msg files
@#  - multi_topics (List) list of all multi-topic names
@###############################################
@{
import genmsg.msgs
import gencpp
from px_generate_uorb_topic_helper import * # this is in Tools/

topic_names = [single_spec.short_name for single_spec in spec]
num_topics = len(topic_names)
}@
#include <px4_config.h>
#include <px4_tasks.h>
#include <px4_posix.h>
#include <unistd.h>
#include <stdio.h>
#include <poll.h>
#include <string.h>
#include <termios.h>


#include <microcdr/microCdr.h>
#include <uORB/uORB.h>

#include "UART_node.h"


@[for topic in topic_names]
#include <uORB/topics/@(topic).h>
@[end for]

extern "C" __EXPORT int general_trans_main(int argc, char *argv[]);

int general_trans_main(int argc, char *argv[])
{
    if (argc < 2)
    {
        errx(1, "need a serial port name as argument");
    }
    
    UART_node m_uartNode;
    m_uartNode.init_uart(argv[1]);
    char rx_buffer[210];
    char buffer[MICROCDR_INIT_BUF_LENGTH];

    /* subscribe to topics */
    px4_pollfd_struct_t fds[@(num_topics)];

@[for id, topic in enumerate(topic_names)]
    int @(topic)_fd = orb_subscribe(ORB_ID(@(topic)));
    orb_set_interval(@(topic)_fd, 1000);
    fds[@(id)].fd = @(topic)_fd;
    fds[@(id)].events = POLLIN;
@[end for]

    /* advertise topics */
@[for id, topic in enumerate(topic_names)]
    struct @(topic)_s @(topic)_data;
    memset(&@(topic)_data, 0, sizeof(@(topic)_data));
    //orb_advert_t @(topic)_pub = orb_advertise(ORB_ID(@(topic)), &@(topic)_data);
@[end for]

    int error_counter = 0;

    for (int i = 0; i < 50; ++i)
    {
        int poll_ret = px4_poll(fds, @(num_topics), 1000);

        if (poll_ret == 0)
        {
            PX4_ERR("Got no data within a second");
        }
        else if (poll_ret < 0)
        {
            if (error_counter < 10 || error_counter % 50 == 0)
            {
                PX4_ERR("ERROR return value from poll(): %d", poll_ret);
            }
            ++error_counter;
        }
        else
        {
@[for id, topic in enumerate(topic_names)]
            if (fds[@(id)].revents & POLLIN)
            {
                /* obtained data for the first file descriptor */
                struct @(topic)_s data;
                /* copy raw data into local buffer */
                orb_copy(ORB_ID(@(topic)), @(topic)_fd, &data);
                
                uint32_t length = 0;
                serialize_@(topic)(&data, buffer, &length);


                printf("<-@(id): ");
                for (int c=0; c < sizeof(data); ++c) printf("%hhu ", buffer[c]);
                printf("\n");
                m_uartNode.writeToUART((char)@(id), buffer, length);
            }
@[end for]
        }

        char topic_ID = 255;
        uint8_t length = m_uartNode.readFromUART(&topic_ID, rx_buffer, rx_buffer);
        if (0 != length)
        {
@[for id, topic in enumerate(topic_names)]
            if (topic_ID == @(id)) {
                printf("->%d: ", topic_ID);
                for (int c=0; c < length; ++c) printf("%hhu ", rx_buffer[c]);
                printf("\n");
                // printf("Received @(topic) \n");

                deserialize_@(topic)(&@(topic)_data, buffer);
                //orb_publish(ORB_ID(@(topic)), @(topic)_pub, &@(topic)_data);

            }
@[end for]
        }
        usleep(10000);
    }
    PX4_INFO("exiting");
    fflush(stdout);
    return OK;
}